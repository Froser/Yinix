Yinux 开发手册

1. 开发环境配置
  1) 开发环境介绍
  Yinux推荐的开发环境是Linux (Ubuntu)。如果是在Windows下开发，建议使用Cgywin。另外，由于Windows平台上不能生成ELF文件格式，因此链接脚本(./kernel/Kernel.lds)也需要做对应地修改。不过本工程暂未对Windows下的环境进行支持。
  初次编译工程时，其运行bootstrap.sh，它会下载编译所需要的所有依赖。根目录下有另外2个脚本：build.sh和run.sh，它们分别表示构建工程，以及构建工程并且开始调试它。
  工程编译完之后，中间文件和最终结果文件均存放在./bin目录下。其中：
  - ./bin/boot.img是操作系统的img，目前仅是一个1.44MB软盘镜像文件。
  - ./bin/system.output.txt是操作系统反汇编后的结果文件。可以对照此文件，结合bochs来进行设置断点和调试。
  - ./bin/system是操作系统内核文件
  - ./bin/kernel.bin是提取二进制内容后的操作系统内核文件，它通过objcopy，提取了system中的主要section。

  2) 新手上路
  当你编好了工程之后，执行run.sh，将会打开bochs的调试界面。输入以下指令：
  `pb 0x7c00`
  bochs虚拟机将会在0x7c00处设下一个断点，这也是Legacy BIOS启动模式下的第一个指令开始的地方。接下来，Yinux将会进行引导，将初始化系统的代码载入0x10000，因此接下来输入下列指令：
  `pb 0x10000`
  执行完初始化代码之后，系统进入了IA-32e长模式，内核被加载到了0x100000。从0x100000开始，存放着GDT、页表等数据，内核的入口为0x106000，所以输入`pb 0x106000`即可在内核入口处设置断点，开始调试。

2. 架构及开发手册
  Yinux基于Intel Core i7实现了IA-32e (x86_64)下的一个操作系统。目前采取的是传统BIOS引导+软驱启动，不过之后也会对UEFI进行支持。
  1) 引导部分
  引导分为两部分。第一部分是实现FAT12的读取，将第二部分的引导载入0x10000处。第二部分引导主要是让系统从实模式进入保护模式，再进入长模式，最后加载内核。
  第一部分引导代码位于./boot/floppy_boot.asm，生成boot.bin。Search_Loader_Begin、Search_Loader_File等系列Search***函数，定义了FAT12读取文件的功能，查找loader.bin，并且将它拷贝到0x1000:0x0000中，最后用长跳转跳到0x1000:0x0000中执行loader.bin中的内容。除了寻找loader.bin外，这一部分代码刚好是FAT12的第一个扇区(512字节)，因此定义了FAT12的相关参数。
  第二部分引导代码位于./boot/loader.asm中，生成loader.bin供第一部分引导读取。它主要依次做了以下几件事情：
    1. 定义了临时GDT, IDT，临时页表，用于进入保护模式和实模式
    2. 打开A20 Gate，允许寻址超过20位。
    3. 寻找并加载kernel.bin到0x100000。
    4. 设置vbe，帧缓存。
    5. 获取内存信息，并保存到0x7e00。
    6. 设置msr, cr0, cr3，进入保护模式，再进入长模式。
    7. 跳转到0x106000，内核头部入口。

  2) 内核头部
    内核头部代码实现于./kernel/head.S。它是汇编和C语言之间的桥梁。
    头部负责创建正式的页表GDT, TSS, IDT：
    Yinux采用3级页表(PDE.PS=1)，大小为每个物理页2MB。页表表头PML4E位于0x101000。
    Yinux的GDT选择子如下：
    | 索引 | 选择子 | 描述           |
    | 0    | 0      | NULL           |
    | 1    | 0x08   | 内核64位代码段 |
    | 2    | 0x10   | 内核64位数据段 |
    | 3    | 0x18   | 用户64位代码段 |
    | 4    | 0x20   | 用户64位数据段 |
    | 5    | 0x28   | 内核32位代码段 |
    | 6    | 0x30   | 内核32位数据段 |
    | 7    | 0x38   | 未使用         |
    | 8-9  | 0x40   | 128位TSS段     |
    在头部阶段，IDT中所有条目指向一个默认的中断处理函数int_failure，显示一个未处理的异常，并且进入死循环。在进入内核之后，内核会修改IDT到各自的处理函数。
    一切准备就绪后，它将跳转到内核入口Kernel_Main(位于./kernel/main.c)。

  3) 异常处理
    按照Intel手册，中断向量0x00-0x20为预设的中断，0x20之后为外部中断。前0x20个中断如下：
    ```
    X86_TRAP_DE = 0,    /*  0, Divide-by-zero */
    X86_TRAP_DB,        /*  1, Debug */
    X86_TRAP_NMI,       /*  2, Non-maskable Interrupt */
    X86_TRAP_BP,        /*  3, Breakpoint */
    X86_TRAP_OF,        /*  4, Overflow */
    X86_TRAP_BR,        /*  5, Bound Range Exceeded */
    X86_TRAP_UD,        /*  6, Invalid Opcode */
    X86_TRAP_NM,        /*  7, Device Not Available */
    X86_TRAP_DF,        /*  8, Double Fault */
    X86_TRAP_OLD_MF,    /*  9, Coprocessor Segment Overrun */
    X86_TRAP_TS,        /* 10, Invalid TSS */
    X86_TRAP_NP,        /* 11, Segment Not Present */
    X86_TRAP_SS,        /* 12, Stack Segment Fault */
    X86_TRAP_GP,        /* 13, General Protection Fault */
    X86_TRAP_PF,        /* 14, Page Fault */
    X86_TRAP_SPURIOUS,  /* 15, Spurious Interrupt */
    X86_TRAP_MF,        /* 16, x87 Floating-Point Exception */
    X86_TRAP_AC,        /* 17, Alignment Check */
    X86_TRAP_MC,        /* 18, Machine Check */
    X86_TRAP_XF,        /* 19, SIMD Floating-Point Exception */
    X86_TRAP_IRET = 32, /* 32, IRET Exception */
    ```
    目前，我们没有使用IA-32e的IST机制，因此还是使用传统的中断调用(ist = 0)。
    trap.c中提供了3个函数来设置IDT与其对应的处理函数：
    set_intr_gate: 指定一个中断的处理函数，其中DPL=0 (Ring0)
    set_trap_gate: 指定一个陷阱的处理函数，其中DPL=0 (Ring0)
    set_system_gate: 指定一个系统的处理函数，其中DPL=3 (Ring3)

    在Intel文档的描述中，对于没有发生特权级变化的场景下，栈空间不需要被切换，因此栈上内容如下：
    |         | <-- 被中断之前ESP
    | EFLGAS  |
    |   CS    |
    |   EIP   |
    | errcode | <-- 进入中断时的ESP
    | 低地址..|

    在./kernel/entry.S中，记录了中断向量的处理函数。异常处理入口以xxx名称的汇编代码开头，而实际上处理函数为C语言所写的do_xxx，例如异常#DE的devide_error和do_devide_error。
    异常处理入口，例如devide_error，它首先压栈了一个立即数0，表示它的errcode。需要注意的是，并不是所有预置的中断都带有错误码，因此对于这类中断，压入一个0 '假装'是错误码。对于有errcode的异常，则不需要push $0了。它们分别以T_ENTRY_NO_ERRCODE和T_ENTRY作为区分，区别是前置多push $0了。）
    紧接着，它缓存rax到栈上，并且获取实际的处理函数的地址do_divide_error到rax，然后调用error_code过程。

