Yinux 开发手册

1. 开发环境配置
  1) 开发环境介绍
  Yinux推荐的开发环境是Linux (Ubuntu)。如果是在Windows下开发，建议使用Cgywin。另外，由于Windows平台上不能生成ELF文件格式，因此链接脚本(./kernel/Kernel.lds)也需要做对应地修改。不过本工程暂未对Windows下的环境进行支持。
  初次编译工程时，其运行bootstrap.sh，它会下载编译所需要的所有依赖。根目录下有另外2个脚本：build.sh和run.sh，它们分别表示构建工程，以及构建工程并且开始调试它。
  工程编译完之后，中间文件和最终结果文件均存放在./bin目录下。其中：
  - ./bin/boot.img是操作系统的img，目前仅是一个1.44MB软盘镜像文件。
  - ./bin/system.output.txt是操作系统反汇编后的结果文件。可以对照此文件，结合bochs来进行设置断点和调试。
  - ./bin/system是操作系统内核文件
  - ./bin/kernel.bin是提取二进制内容后的操作系统内核文件，它通过objcopy，提取了system中的主要section。

  2) 新手上路
  当你编好了工程之后，执行run.sh，将会打开bochs的调试界面。输入以下指令：
  `pb 0x7c00`
  bochs虚拟机将会在0x7c00处设下一个断点，这也是Legacy BIOS启动模式下的第一个指令开始的地方。接下来，Yinux将会进行引导，将初始化系统的代码载入0x10000，因此接下来输入下列指令：
  `pb 0x10000`
  执行完初始化代码之后，系统进入了IA-32e长模式，内核被加载到了0x100000。从0x100000开始，存放着GDT、页表等数据，内核的入口为0x106000，所以输入`pb 0x106000`即可在内核入口处设置断点，开始调试。

2. 架构及开发手册
  Yinux基于Intel Core i7实现了IA-32e (x86_64)下的一个操作系统。目前采取的是传统BIOS引导+软驱启动，不过之后也会对UEFI进行支持。
  1) 引导部分
  引导分为两部分。第一部分是实现FAT12的读取，将第二部分的引导载入0x10000处。第二部分引导主要是让系统从实模式进入保护模式，再进入长模式，最后加载内核。
  第一部分引导代码位于./boot/floppy_boot.asm，生成boot.bin。Search_Loader_Begin、Search_Loader_File等系列Search***函数，定义了FAT12读取文件的功能，查找loader.bin，并且将它拷贝到0x1000:0x0000中，最后用长跳转跳到0x1000:0x0000中执行loader.bin中的内容。除了寻找loader.bin外，这一部分代码刚好是FAT12的第一个扇区(512字节)，因此定义了FAT12的相关参数。
  第二部分引导代码位于./boot/loader.asm中，生成loader.bin供第一部分引导读取。它主要依次做了以下几件事情：
    1. 定义了临时GDT, IDT，临时页表，用于进入保护模式和实模式
    2. 打开A20 Gate，允许寻址超过20位。
    3. 寻找并加载kernel.bin到0x100000。
    4. 设置vbe，帧缓存。
    5. 获取内存信息，并保存到0x7e00。
    6. 设置msr, cr0, cr3，进入保护模式，再进入长模式。
    7. 跳转到0x106000，内核头部入口。

  2) 内核头部
    内核头部代码实现于./kernel/head.S。它是汇编和C语言之间的桥梁。
    头部负责创建正式的页表GDT, TSS, IDT：
    Yinux采用3级页表(PDE.PS=1)，大小为每个物理页2MB。页表表头PML4E位于0x101000。
    Yinux的GDT选择子如下：
    | 索引 | 选择子 | 描述           |
    | 0    | 0      | NULL           |
    | 1    | 0x08   | 内核64位代码段 |
    | 2    | 0x10   | 内核64位数据段 |
    | 3    | 0x18   | 用户64位代码段 |
    | 4    | 0x20   | 用户64位数据段 |
    | 5    | 0x28   | 内核32位代码段 |
    | 6    | 0x30   | 内核32位数据段 |
    | 7    | 0x38   | 未使用         |
    | 8-9  | 0x40   | 128位TSS段     |
    在头部阶段，IDT中所有条目指向一个默认的中断处理函数int_failure，显示一个未处理的异常，并且进入死循环。在进入内核之后，内核会修改IDT到各自的处理函数。
    一切准备就绪后，它将跳转到内核入口Kernel_Main(位于./kernel/main.c)。